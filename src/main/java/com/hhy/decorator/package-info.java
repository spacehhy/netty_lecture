package com.hhy.decorator;

/**
 * java中的IO:
 * java提供了两种IO;
 * 第一种是普通的java.io包下的传统的IO(阻塞IO);
 * 第二种是jdk1.4引入的NIO,NIO即可以理解为new io,也可以认为是non-blocking IO(非阻塞IO);
 * 日常开发时和NIO直接打交道的时候并不多,然而NIO在很多网络框架都得到了非常重要的应用,尤为典型的是在netty当中NIO是得到了大量使用
 * 要想更好的理解netty,NIO的理解就是一个刻不容缓的这样一件事情,
 * 要想系统的学习NIO,应分为两个步骤,第一个步骤对IO本身就是传统IO有一个非常透彻很深入的理解,其次NIO原理上的东西要有很好的掌握
 * IO与NIO 在具体操作时其实存在一个很大的区别,当然了他们中间有相同的地方,有一些相似的地方,设计jdk时,IO里面相关的类也可以通过他里面相关的方法
 * 比如FileInputStream或FileOutputStream可以通过对应的getChannel方法来转换到NIO,得到了NIO相关的对象,接下来再通过NIO相关的API就可以实现
 * 异步的非阻塞的IO操作,因此我们在学习NIO之前,总结和回顾IO内容。从而理解IO本身,第二方面加深IO所用到的设计模式的理解。
 *
 * Java I/O系统
 * 理解I/O系统
 * 熟练使用java.io包中的相关类与接口进行I/O编程
 * 掌握Java I/O的设计原则与使用的设计模式
 *
 * p.s. 对程序语言设计者来说,设计一个令人满意的I/O(输入输出)系统,是件极艰巨的任务  摘自《Thinking in Java》
 * IO的输入输出主要是跟外设打交道的,比如像读取信息到程序当中,信息的来源可能是键盘标准输入,也可能是来源于网络,也可以来源自内存的字节数组,
 * 外设的来源可能是多种多样,那么输出也是类似的,那么如何去对底层的实现细节做一个很好的屏蔽,使得开发人员不去关注底层内容,让他专注于通过IO系统
 * 所提供的一些非常好用的API就可以完成我们日常的IO相关的处理工作
 *
 * 流的概念 （Stream）
 *   Java程序通过流来完成输入/输出。流是生产或消费信息的抽象。流通过Java的输入/输出系统与物理设备链接。尽管与它们链接的物理设备不尽相同
 *   ,所有流的行为具有同样的方式。这样,相同的输入/输出类和方法适用于所有类型的外部设备。这意味着一个输入流能够抽象多种不同类型的输入:从
 *   磁盘文件,从键盘或从网络套接字。同样,一个输出流可以输出到控制台,磁盘文件或相连的网络。流是处理输入/输出的一个洁净的方法,例如他不需
 *   要代码理解键盘和网络的不同。Java中流的实现是java.io包定义的类层次结构内部的。
 *
 * 节点流: 节点流是直接与设备打交道的,比如从文件当中进行信息的读取,我们就会创建一个FileInputStream流对象,FileInputStream是直接与文件
 *        相连的,因此称之为节点流
 * 过滤流: 我们可以对FileInputStream进行包装,包装完之后,比如增加了带缓冲的BufferedInputStream,使的带和缓冲区的这种输入,那么BufferedInputStream
 *        本身就是一个过滤流,过滤流一定是要依附于一个节点流才能创建出来的,换句话说它的构造方法里会有一个接受一个节点流的参数,作为他的一个构造方法的参数
 *        来去进行构建,节点流一定是跟我们的目标(目的地)直接连接交互,而过滤流是对节点流的一个包装,包装之后,我们可以对已经包装好的过滤流,再去对它进行包装
 *        换句话说我们再去使用一个过滤流对已有的过滤流进行包装。这种方式是我们日常开发中经常使用到的一种方式，这里面实际上用到了一种设计模式，
 *
 * InputStream的类层次图解释：
 * 蓝色的为节点流，即直接继承InputStream的非FilterInputStream子类
 * 黄色的为过滤流，即直接继承FilterInputStream的子类(它们是对既有的节点流或既有的过滤流进行了包装,封装)形成了更为完整,功能更为强大的流供用户使用
 *
 * 装饰模式的角色:
 *     抽象构件角色: 例 InputStream
 *     具体构件角色: 节点流
 *     装饰角色: 过滤流(FilterInputStream)
 *     具体装饰角色: 例 DataInputStream 等
 *
 * 例如:
 * AAA
 * BBB
 * CCC
 *
 * new CCC(new BBB(new AAA()));
 *
 * new BBB(new AAA());
 *
 * new AAA();
 *
 * IO中使用大量装饰模式,其中以BufferedInputStream举例
 * BufferedInputStream带缓冲的输入流,并且它是一个过滤流,因为继承FilterInputStream,而FilterInputStream是过滤流顶层类,是装饰角色
 *
 * volatile 关键字:
 * 1.内存可见性处理,内存在程序代码运行时,比如多线程每个线程都有一个工作内存,工作内存的每一个线程会有自己的工作内存,此外还有一个主内存,
 *   如果一个线程修改了自己工作内存的变量值的话,如果不加volatile那么在修改完的某一瞬间,他并不会更新到主内存,换句话说,其他线程里面在他的
 *   工作内存当中所看到的同一个变量的值就跟另外一个线程看到的值是不一样的(修改之前的值),如果加上volatile的话就做到了内存可见性,一个线程
 *   修改了自己工作内存中的值的话,就会立刻的被刷新到其他的线程工作内存当中,实际上就是其他工作线程使用volatile类型在去使用volatile修饰的
 *   变量时,就会首先刷新一下自己的工作内存。即处理多线程内存可见性问题
 * 2.防止指令重排序,因为java编译之后,编译器为了优化代码,编译好后生成字节码,往往与我们程序所定义的顺序存在不一致的情况,如果加上volatile
 *   就可以避免这种情况的发生
 *
 * 在整个的IO体系当中,装饰模式就成为了构建IO系统最底层最核心的内容
 * 传统的IO是面向(stream)流编程的,流分为输入,输出流;又分为过滤流和节点流,过滤流是包装过滤流和节点流的,而节点流是直接跟我们的目标对象,目标文件
 * 目标目的地或源打交道的,在节点流和过滤流的处理方式上IO体系使用的是装饰设计模式,可以在很大程度上避免有更多子类的产生,并且可以在运行期,去丰富
 * 我们构造出来的对象它所具备的功能,因为IO体系已经有很多很多的类了,如果不使用装饰模式的话,会导致类的数量又极具膨胀,并且实现起来非常不灵活,所以
 * 通过这种装饰模式的合理利用,就可以使我们在很大程度上,一方面让我们IO的功能还是保持非常健全的功能,此外还可以包装我们IO体系当中类的数量不至于过
 * 多的膨胀。
 * IO、体系的回顾、装饰模式在IO体系的合理利用！！！
 *
 *
 */