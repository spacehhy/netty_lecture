package com.hhy.thirdexample;

/**
 * 这是一个基于netty的服务器与多个客户端之间广播,简单聊天程序的 demo
 * 服务器启动之后,会有多个客户端跟客户端建立连接 比如A、B、C三个客户端与
 * 服务端建立好连接,A如果发出了一条消息之后,A本身是把消息发送给服务端,
 * 服务器端通过广播的方式,把消息发送给与之连接的所有的客户端,包括A这个客户端
 * 那么这里需要做一个判断,如果A自己发送的,自己收回来之后,会在消息上写明 自己
 * 表示消息是自己发送的,那么其他用户把对应的内容显示出来。
 * 实际上这就实现了一种更为复杂一点的一种TCP编程  (chat: 聊, 交谈, 闲谈)
 *
 * handlerAdded     表示服务器端与客户端建立连接 参数少了msg 表示连接建立不携带任何消息
 * ChannelGroup     channel组 用于放置一个个 channel
 * handlerRemoved   连接断掉以后我们能够进行处理的唯一回调一个方法
 * channelActive    连接属于活跃状态
 * channelInactive  连接属于不活跃状态
 *
 * server:
 * /127.0.0.1:8635上线
 * /127.0.0.1:8667上线
 * /127.0.0.1:8748上线
 *
 * client1:
 * [服务器]… /127.0.0.1:8667加入
 * [服务器]… /127.0.0.1:8748加入
 * 我是第一个客户端(控制台输入)
 * [自己]的消息: 我是第一个客户端
 *
 * client2:
 * [服务器]… /127.0.0.1:8748加入
 * /127.0.0.1:8635发送的消息: 我是第一个客户端
 *
 * client3:
 * /127.0.0.1:8635发送的消息: 我是第一个客户端
 *
 * server端答应数字 0 1 2 原因
 * 当客户端离线 handlerRemoved 执行System.out.println(channelGroup.size());
 * 打印ChannelGroup内 channel 个数 验证channel断线时 ChannelGroup自动调用
 * channelGroup.remove(channel);
 *
 * webSocket 程序中 ChannelGroup实现消息群发 最典型服务器端的消息推送
 * 消息推送:
 *  1.系统推送   ios:通知中心 android:系统自带推送机制、小米推送、华为推送
 *  2.应用内推送 需要客户端与服务器端建立好一个长连接，像微信一样打开app如果有人发消息，立刻就能收到
 *             同样回消息，对方也能立刻收到，当实现服务器端推送，向所有用户或者向某一些用户推送一条
 *             消息的时候，服务器端实际上是要保存这客户端与之相连的channel对象，当客户端在线时，向
 *             客户端进行推送，如果客户端断线比如（手机关机、处于飞行模式或者没信号），这时客户端与
 *             服务器端处于断线状态，那么这个时候服务器端需要把这个消息（没有发送成功或检测到对方处
 *             于断线状态），需要将消息发送到离线消息里面 （mysql，mongodb）数据库，当客户端下次
 *             建立好连接之后，我们从离线数据库里面把数据给提取出来，提取出来之后，再去向客户端进行
 *             发送，如果客户端返回一个ACK (Acknowledgement）即是确认字符；表示接收成功的话，我
 *             们从离线数据库里面，把这个消息，要么删掉，要么保存在一个备份表里面，一系列操作。这就
 *             是典型的即时通讯的应用的设计模式
 *
 *
 *
 */