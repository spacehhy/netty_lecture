package com.hhy.fourthexample;

/**
 * 关于心跳以及心跳检查机制 ,读/写/读写 demo
 * 心跳：heartbeat
 * app与服务器端建立长连接;或者服务器端某些软件之间形成集群,比如(zookeeper形成的集群,kafka形成的集群,mongodb形成的集群)
 * 对于服务器端这些软件,他们构成了这种集群,几乎无一例外的他们之间采用了TCP的方式,进行集群之间节点与节点之间的通信,为什么要实
 * 现这种通信呢?其实这样的,既然是集群,我们应该认为集群里面各个节点其实都是类似的,可能会有一个主节点,其他是从节点;比如对mongodb
 * 来说会有一个master节点,其他节点叫做slave,zookeeper来说,会有一个leader,其他的我们叫做secondary,总之有一个主的机器和
 * 若干从的机器;那么主这个机器呢,一般负责读写,从的机器呢可能负责相关的一些读这样的一些请求,因为主这个机器呢,一旦数据发生变化,它
 * 需要通过异步的方式,把数据同步到其他的从节点上,同步的方式其实是有多种多样的,一般来说我们会采用日志的方式来进行同步,比如新增加
 * 了一个相关内容,日志里就会有一个相关的记录,从节点会每隔一段时间去拉取这个日志,把相关信息更新到自己的节点上,因此在这种集群的软件
 * 环境下,节点与节点之间的数据都不是实时一致性,而是最终一致性。
 * 实时一致性:在同一时刻两个节点或多个节点之间的数据是完全一样的
 * 最终一致性:节点与节点之间在某一时刻,数据可能存在不一致的情况,但是最终经过一段时间(几毫秒,几百毫秒,几秒钟)后,节点与节点的这些数
 *          据一定会达到相同的结果
 *
 * 节点与节点之间如何去保证他们的通信呢?
 * 在一个集群当中,可能某一个节点,在某一个时刻,可能会出现各种各样的情况,比如说,节点挂掉了或者节点因为网络的阻塞可能数据无法到达,其实
 * 这种情况是非常普遍,多种多样的,那么节点与节点之间是如何感知到 如A节点感知B点还活着,B节点感知A节点还活着,那么这就需要节点与节点之
 * 间通过定时的每间隔一段时间(比如每两秒钟/每五秒钟)等等,发出一个心跳包,比如每隔3秒钟A会向B发出一个心跳,B收到A的心跳后,向A返回一个
 * 结果,至于发送的心跳包数据是什么内容,接收方收到心跳返回的是什么内容,这个内容本身并不重要,关键是说是不是真正的收到了,收到了之后是不
 * 是又把结果返回给对方,这个是关键的。
 * 比如A向B每隔3秒发出一个心跳,那可能经过一段时间,它发出一个心跳,紧接着没有等到对方给他返回一个结果,这个时候呢A是不能断定B还与他保持
 * 连接还是没有保持连接,或者说B是或者还是已经down掉了,因为可能由于网络的原因这个包就丢掉了,或者没有最终没有到达B端,这种情况下,A可能
 * 重复发送一次,如果还是没有收到,又重复发送一次,你可以设置到底发送多少次,比如说发送三次,如果对方还是没有收到,你还是没有收到对方的响应
 * 的话,那么这个时候你就可以认为对方挂掉了,这种情况下,将你认为对方已经挂掉了的这个节点,从节点中踢出去,那么当它恢复之后,又会建立心跳机
 * 制,这是在集群当中或者长连接当中,最为有效的避免网络中断的一个最重要的一个保障措施。
 * 回到app与服务器的长连接，真实情况远比想象复杂，比如说一个手机客户端与服务端建立好长连接后，客户端没有退出应用，这种情况下，客户端在
 * 在手机上开了飞行模式，或强制把手机关机，那么在这种情况下，(服务器端与客户端，他们双方之间是根本感知不到这个连接是断掉的，这个是TCP
 * 编程很重要的一个特点)服务器端handlerRemoved是不会被调用的,既然不会被调用,服务器端就认为客户端还是与之保持连接的,但实际上客户端
 * 已经开启飞行模式了,已经没有信号了,在这种情况下,服务器端如果再向客户端推送任何消息,客户端肯定是接收不到的,对于netty来说,在这种情况
 * 下,如果服务器端向客户端推送消息的话,经过了一段时间之后,服务器端就会抛出异常,因为这个消息是到达不了的。
 * 那既然这种情况下根本没有检测机制能去检测到客户端是已经强制关机了，或者是已经开飞行模式了，那怎么去处理这种情况呢，实际上对于这种情况
 * 的处理就要采取心跳，就是说App客户端与服务端，一旦建立好长连接之后，客户端可能每隔（时间自定义）3秒就像服务器发送一个心跳包，服务器
 * 端收到心跳包之后呢，就像客户端返回一个相应的结果，也是一个心跳，那么客户端在规定的时间内，收到了之后，它就认为这个连接还是在的，还是
 * 跟服务器端保持连接，如果经过了一段时间之后，没有收到客户，客户端再去发送，还没有收到再去发送，还没有收到，那么在这种情况下，客户端就
 * 会认为与服务器之间的这种连接是断掉的，那么这种情况下，客户端就会强制的调用相应的close方法，把连接断掉，断掉之后再去与服务器建立新的
 * 连接，那么这是长连接的最为重要也是最为基本的一个检测技术。作为一个IM开发的一个系统来说并不是很容易能够设计出来的，达成的。
 *
 * netty对于心跳检测或者说超时机制提供了哪些完备的基础设施,甚至说对于心跳包,netty也提供了相应的功能就是 PingMessage和PongMessage
 * netty的这种 handler机制非常非常类似于 过滤器,拦截器模式, 设计模式中叫责任链模式 Chain of Responsibility Pattern 就是说一个请求过来
 * 之后先通过第一个handler,第一个handler处理完成后再通过第二个handler,然后一直到达最后的handler,真正处理完之后再原路(相反的顺序)返回
 * IdleStateHandler    : 该方法有三个参数 //空闲检测处理器 读超时 写超时 读写超时
 * userEventTriggered  : 用户事件被处罚 触发某一个事件后,该方法被调用 该事件被触发之后,默认情况下将事件转发给管道中的下一个handler对象
 * 目标,重写 userEventTriggered 方法增加自己的判断逻辑
 *
 * 启动server 和 client
 * 读空闲:
 * 七月 11, 2019 8:56:31 下午 io.netty.handler.logging.LoggingHandler channelRead
 * 信息: [id: 0xb47237c6, L:/0:0:0:0:0:0:0:0:8899] READ: [id: 0xd5bbc97c, L:/127.0.0.1:8899 - R:/127.0.0.1:13294]
 * 七月 11, 2019 8:56:31 下午 io.netty.handler.logging.LoggingHandler channelReadComplete
 * 信息: [id: 0xb47237c6, L:/0:0:0:0:0:0:0:0:8899] READ COMPLETE
 * /127.0.0.1:13294超时事件: 读空闲
 *
 * 写空闲
 * server :
 * /127.0.0.1:13364超时事件: 写空闲
 * client :
 * 111
 * 222
 * 333
 * 444
 * 555
 *
 * 读写空闲 :
 * server :
 * /127.0.0.1:13468超时事件: 读写空闲
 *
 */